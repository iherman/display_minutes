/**
 * Replace irc nicknames with real names (if available) in W3C minutes
 * 
 */

import { type Params, getParams }    from './params.ts';
import { type FileName, getMinutes } from "./data.ts";

type Nicknames = Record<string,string> ;

// special lines:

const Specials: RegExp[] = [
    /<dt>Present<\/dt><dd>(.*)<\/dd>/,
    /<dt>Chair<\/dt><dd>(.*)<\/dd>/,
    /<dt>Regrets<\/dt><dd>(.*)<\/dd>/,
    /<dt>Scribe<\/dt><dd>(.*)<\/dd>/
] 

/**
 * Modify one minute file: extract the nicknames, and change them to their full name.
 * 
 * Nicknames are extracted:
 * 
 * - from the header (present, chair, scribe)
 * - from the content, looking at the `<cite>` element
 * 
 * as generated by the scribe tool of W3C.
 * 
 * @param input - Input file name
 * @param nicknames - Nick mappings to real names
 * @param out - Output file name. If empty, input file name is reused
 */
async function oneFile(input: FileName, nicknames: Record<string, string>, out: FileName = ""): Promise<void> {
    const getNicks = (content: string[]): string[] => {
        let nicks: string[] = [];
        for( const line of content) {
            // action to be taken for each line of the minutes
            {
                // handle the real minutes
                const regex_result = line.match(/<cite>(.*)<\/cite>/);
                if (regex_result !== null) {
                    nicks.push(regex_result[1]);
                }
            }

            // handle special lines: present, scribe, regrets, chairs
            for (const regex of Specials) {
                const regex_result = line.match(regex);
                if (regex_result !== null) {
                    const header_nicks: string[] = regex_result[1].split(",").map((n: string): string => n.trim());
                    nicks = [...nicks, ...header_nicks] 
                }
            }
        }

        // Time for some cleanups on the nicknames...
        const final_nicks = nicks
            .map((nick: string): string => {
                nick = nick.toLowerCase();
                if (nick.startsWith('&lt;')) {
                    // these are lines not produced by the scribe
                    nick = nick.substring(4, nick.length - 4);
                }
                if (nick.endsWith(':')) {
                    // the scribe puts this sign there
                    nick = nick.substring(0, nick.length - 1);
                }
                if (nick.endsWith("_")) {
                    // the irc log adds an underscore to the nickname time-to-time
                    nick = nick.substring(0, nick.length - 1);
                }
                return nick;
            })
            // remove empty nicknames, as well the entries of zakim
            .filter((input: string): boolean => input !== "" && input !== "zakim");

        // Remove duplicates
        return [...new Set(final_nicks)];
    };

    const output: string = out || input;
    // console.log(`Handling ${input}, stored in ${output}`);

    const content: string[] = (await Deno.readTextFile(input)).split('\n');
    // console.log(`Nicknames: ${getNicks(content)}`)

    // Get all the nicknames in the text, and concentrate on those that have an associated real name
    const nicks: string[] = getNicks(content).filter((nick: string): boolean => nicknames[nick] !== undefined);

    // Systematically change the first occurrence of nicknames with the real names
    const newContent = content.map((line: string): string => {
        // Filter out the entries generated by zakim
        if (line.match("<cite>&lt;Zakim&gt;</cite>") !== null) {
            return "";
        }

        // This somewhat convoluted way of handling is necessary to avoid double settings of, e.g., 
        // nickname pairs like 'wendy' and 'wendyreid' both appearing in the 'present' line:
        // a simple regex replacement would lead to things like Wendy Reid Reid or so 
        const one_nick = (current: string, nick: string, replacement: string): string => {
            const reg = `${nick}([,<:&])`;
            const regex = new RegExp(reg, 'i');
            const regex_result = line.match(regex);
            if (regex_result !== null) {
                current = current.replace(regex, `${replacement}${regex_result[1]}`);
            } 
            return current           
        }
        // The same match is done twice; the nicknames may include a '_' character at the end, an artefact of IRC
        for (const nick of nicks) {
            const replacement = nicknames[nick];
            line = one_nick(line, nick, replacement);
            line = one_nick(line, `${nick}_`, replacement);
        }

        // Another scribing problem: the same person appearing in, say, the present list twice, with different
        // nicknames
        for (const regex of Specials) {
            const regex_result = line.match(regex);
            if (regex_result !== null) {
                const names = regex_result[1].split(',').map((name: string): string => name.trim());
                const unique_names = [...new Set(names)].join(', ');
                line = line.replace(regex_result[1], unique_names);
            }
        }
        return line;
    }).filter((line: string):boolean => line !== "");

    // write the result into the output
    await Deno.writeTextFile(output, newContent.join('\n'));
}

/* ============================================================================================================= */

/**
 * Runner on update minutes' function on all files in parallel
 */
export async function handle_nicknames(): Promise<void> {
    // const getMinutesList = async (dir: string): Promise<string[]> => {
    //     const files: string[] = [];
    //     for await (const entry of Deno.readDir(dir)) {
    //         if (entry.isFile && !non_minute_files.includes(entry.name)) {
    //             // filter out the index and resolution files, if applicable
    //             files.push(`${MINUTES_DIR}/${entry.name}`);
    //         }
    //     }
    //     return files;
    // }

    const params: Params = await getParams();
    if (!params.nicknames) {
        console.error("No nickname mapping file has been provided.")
    } else {
        // Get hold of the nicknames
        const nicknames: Nicknames = JSON.parse(await Deno.readTextFile(params.nicknames)) as Nicknames;
        const minutes: FileName[] = await getMinutes(params.directory);
 
        const minutesPromises: Promise<void>[] = minutes.map((minute: FileName) => oneFile(minute, nicknames));
        // const minutesPromises = [oneFile('../minutes/2025-10-09-dc.html', nicknames, '../minutes/2025-10-09-dc.html'.replace("minutes", "test"))]

        // Run the minute handling in parallel. If one fails, be it, we just forget about the file...
        await Promise.allSettled(minutesPromises);
        console.log("Real names generated successfully")
    }
}
